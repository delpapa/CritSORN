from __future__ import division
from pylab import *
import utils
utils.backup(__file__)

from delpapa.plot import plot_results as plot_results_single

from common.sources import CountingSource, TrialSource, NoSource
from common.experiments import AbstractExperiment
from common.sorn_stats import *

class Experiment_test(AbstractExperiment):
    def start(self):
        super(Experiment_test,self).start()   
        c = self.params.c
                                                                    
        self.inputsource = NoSource(N_i=c.N_u_e)
        stats_all = [
                     InputIndexStat(),
                     InputUnitsStat(),
                     #~ ParamTrackerStat(),
                    ]
        stats_single = [
                         ActivityStat(),
                         #~ ActivityInhibStat(),
                         EndWeightStat(),
                         SpikesStat(),
                         #~ SpikesInhStat(),
                         ConnectionFractionStat(),
                        ]
        return (self.inputsource,stats_all+stats_single,stats_all)
        
    def reset(self,sorn):
        super(Experiment_test,self).reset(sorn)
        c = self.params.c
        stats = sorn.stats # init sets sorn.stats to None
        sorn.__init__(c,self.inputsource)
        sorn.stats = stats
            
    def run(self,sorn):
        super(Experiment_test,self).run(sorn)
        c = self.params.c
        
        print '\n\nTransient...'
        sorn.simulation(c.steps_transient)
        
        print '\n\nOnly noise input:'  
        sorn.simulation(c.steps_noise)                                   # more supercritical effects
        
        print '\n\nExternal Input:'  
        
        #~ sorn.W_ee.c.eta_stdp = 0    
        #~ sorn.W_ei.c.eta_istdp = 0   
        #~ sorn.W_ee.c.sp_prob = 0      
        #~ c.eta_ip = 0               
        
        # external input definition
        #~ word_full = ['ABCDEFGHIJ']
        word1 = "A"
        word2 = "B"
        word3 = "C"
        word4 = "D"
        word5 = "E"
        word6 = "F"
        word7 = "G"
        word8 = "H"
        word9 = "I"
        word10 = "J"
        #~ word11 = "K"
        #~ word12 = 'L'
        #~ word13 = 'M'
        #~ word14 = 'N'
        #~ word15 = "O"
        #~ word16 = "P"
        #~ word17 = "Q"
        #~ word18 = "R"
        #~ word19 = "S"
        #~ word20 = "T"
        #~ word21 = "U"
        #~ word22 = "V"
        #~ word23 = "W"
        #~ word24 = "X"
        #~ word25 = "Y"
        #~ word26 = 'Z'
        words = [word1, word2, word3, word4, word5, word6, word7, \
                word8, word9, word10] # , word11, word12, word13, word14, \
                #~ word15, word16, word17, word18, word19, word20, word21,\
                #~ word22, word23, word24, word25, word26]        
                
        words_len = len(words)
        words_trans = np.ones([words_len,words_len])*(1./10)

        newsource = CountingSource(word_full,words_trans,c.N_u_e,c.N_u_i,avoid=False)
        sorn.source = newsource
        sorn.W_eu = newsource.generate_connection_e(c.N_e)
        sorn.simulation(c.steps_sequence)        
        
        #print '\n\nLetter Sequence (with plasticity):' 
        
        #c.eta_ip = 0.01     
        #~ c.noise_sig = 0.                     # stop noise here 
                      #~ 
        #~ sorn.W_ee.c.eta_stdp = 0.004    
        #~ sorn.W_ei.c.eta_istdp = 0.001   
        #~ sorn.W_ee.c.sp_prob = 0.1         
        
        #newsource2 = NoSource(N_i=c.N_u_e)
        #sorn.source = newsource2
        #sorn.W_eu = newsource2.generate_connection_e(c.N_e)
        #sorn.simulation(c.steps_noise2)     

        return {'source_plastic':self.inputsource,'source_test':newsource}
     
    def plot_single(self,path,filename):
        plot_results_single(path,filename)

